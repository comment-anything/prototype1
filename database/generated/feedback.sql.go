// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: feedback.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const createFeedback = `-- name: CreateFeedback :exec
INSERT INTO "Feedbacks" (
    user_id,
    type,
    content
) VALUES ($1, $2, $3)
`

type CreateFeedbackParams struct {
	UserID  sql.NullInt64  `json:"user_id"`
	Type    sql.NullString `json:"type"`
	Content sql.NullString `json:"content"`
}

func (q *Queries) CreateFeedback(ctx context.Context, arg CreateFeedbackParams) error {
	_, err := q.db.ExecContext(ctx, createFeedback, arg.UserID, arg.Type, arg.Content)
	return err
}

const getFeedback = `-- name: GetFeedback :many
SELECT "F".id, "F".user_id, "U".username, "F"."type", "F"."submitted_at", "F".content, "F"."hidden" FROM "Feedbacks" as "F" INNER JOIN "Users" as "U" ON "U".id = "F".user_id WHERE "F"."hidden" = $1
`

type GetFeedbackRow struct {
	ID          int64          `json:"id"`
	UserID      sql.NullInt64  `json:"user_id"`
	Username    string         `json:"username"`
	Type        sql.NullString `json:"type"`
	SubmittedAt time.Time      `json:"submitted_at"`
	Content     sql.NullString `json:"content"`
	Hidden      sql.NullBool   `json:"hidden"`
}

func (q *Queries) GetFeedback(ctx context.Context, hidden sql.NullBool) ([]GetFeedbackRow, error) {
	rows, err := q.db.QueryContext(ctx, getFeedback, hidden)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFeedbackRow
	for rows.Next() {
		var i GetFeedbackRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Username,
			&i.Type,
			&i.SubmittedAt,
			&i.Content,
			&i.Hidden,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
