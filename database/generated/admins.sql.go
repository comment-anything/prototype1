// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: admins.sql

package generated

import (
	"context"
	"database/sql"
	"time"
)

const getAdmins = `-- name: GetAdmins :many
SELECT 
    "G"."id",
    "G"."assigned_to",
    "UTo".username as "assigned_to_username",
    "G"."assigned_at",
    "G"."assigned_by",
    "UBy".username as "assigned_by_username"
    FROM "AdminAssignments" as "G"
    INNER JOIN "Users" as "UTo" on "G".assigned_to = "UTo".id
    INNER JOIN "Users" as "UBy" on "G".assigned_by = "UBy".id
    WHERE "G".is_deactivation != true
`

type GetAdminsRow struct {
	ID                 int64     `json:"id"`
	AssignedTo         int64     `json:"assigned_to"`
	AssignedToUsername string    `json:"assigned_to_username"`
	AssignedAt         time.Time `json:"assigned_at"`
	AssignedBy         int64     `json:"assigned_by"`
	AssignedByUsername string    `json:"assigned_by_username"`
}

func (q *Queries) GetAdmins(ctx context.Context) ([]GetAdminsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAdmins)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminsRow
	for rows.Next() {
		var i GetAdminsRow
		if err := rows.Scan(
			&i.ID,
			&i.AssignedTo,
			&i.AssignedToUsername,
			&i.AssignedAt,
			&i.AssignedBy,
			&i.AssignedByUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBanRecords = `-- name: GetBanRecords :many
SELECT "BanActions".id, "BanActions".taken_by, "By".username as "taken_by_username", "BanActions".target_user, "To".username as "target_username", "BanActions".reason, "BanActions".taken_on, "BanActions".domain, "BanActions".set_banned_to FROM "BanActions" INNER JOIN "Users" as "By" on "BanActions".taken_by = "By".id INNER JOIN "Users" as "To" on "BanActions".target_user = "To".id
`

type GetBanRecordsRow struct {
	ID              int64          `json:"id"`
	TakenBy         int64          `json:"taken_by"`
	TakenByUsername string         `json:"taken_by_username"`
	TargetUser      int64          `json:"target_user"`
	TargetUsername  string         `json:"target_username"`
	Reason          sql.NullString `json:"reason"`
	TakenOn         sql.NullTime   `json:"taken_on"`
	Domain          sql.NullString `json:"domain"`
	SetBannedTo     sql.NullBool   `json:"set_banned_to"`
}

func (q *Queries) GetBanRecords(ctx context.Context) ([]GetBanRecordsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBanRecords)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBanRecordsRow
	for rows.Next() {
		var i GetBanRecordsRow
		if err := rows.Scan(
			&i.ID,
			&i.TakenBy,
			&i.TakenByUsername,
			&i.TargetUser,
			&i.TargetUsername,
			&i.Reason,
			&i.TakenOn,
			&i.Domain,
			&i.SetBannedTo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentReports = `-- name: GetCommentReports :many
SELECT "CR".id, "CR".reporting_user, "Users".username, "CR".comment, "CR".reason, "CR".action_taken, "CR".time_created From "CommentReports" as "CR" INNER JOIN "Users" on "CR".reporting_user = "Users".id WHERE "CR".action_taken = $1
`

type GetCommentReportsRow struct {
	ID            int64          `json:"id"`
	ReportingUser int64          `json:"reporting_user"`
	Username      string         `json:"username"`
	Comment       int64          `json:"comment"`
	Reason        sql.NullString `json:"reason"`
	ActionTaken   sql.NullBool   `json:"action_taken"`
	TimeCreated   time.Time      `json:"time_created"`
}

func (q *Queries) GetCommentReports(ctx context.Context, actionTaken sql.NullBool) ([]GetCommentReportsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommentReports, actionTaken)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentReportsRow
	for rows.Next() {
		var i GetCommentReportsRow
		if err := rows.Scan(
			&i.ID,
			&i.ReportingUser,
			&i.Username,
			&i.Comment,
			&i.Reason,
			&i.ActionTaken,
			&i.TimeCreated,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDomainModerators = `-- name: GetDomainModerators :many
SELECT 
    "D"."id",
    "D"."assigned_to",
    "UTo".username as "assigned_to_username",
    "D"."assigned_at",
    "D"."assigned_by",
    "UBy".username as "assigned_by_username"
    FROM "DomainModeratorAssignments" as "D"
    INNER JOIN "Users" as "UTo" ON "D"."assigned_to".id = "UTo".id
    INNER JOIN "Users" as "UBy" ON "D"."assigned_by".id = "UBy".id
    WHERE "D"."domain" = $1 AND "D"."is_deactivation" != true
`

type GetDomainModeratorsRow struct {
	ID                 int64     `json:"id"`
	AssignedTo         int64     `json:"assigned_to"`
	AssignedToUsername string    `json:"assigned_to_username"`
	AssignedAt         time.Time `json:"assigned_at"`
	AssignedBy         int64     `json:"assigned_by"`
	AssignedByUsername string    `json:"assigned_by_username"`
}

func (q *Queries) GetDomainModerators(ctx context.Context, domain string) ([]GetDomainModeratorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDomainModerators, domain)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDomainModeratorsRow
	for rows.Next() {
		var i GetDomainModeratorsRow
		if err := rows.Scan(
			&i.ID,
			&i.AssignedTo,
			&i.AssignedToUsername,
			&i.AssignedAt,
			&i.AssignedBy,
			&i.AssignedByUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlobalModerators = `-- name: GetGlobalModerators :many
SELECT 
    "G"."id",
    "G"."assigned_to",
    "UTo".username as "assigned_to_username",
    "G"."assigned_at",
    "G"."assigned_by",
    "UBy".username as "assigned_by_username"
    FROM "GlobalModeratorAssignments" as "G"
    INNER JOIN "Users" as "UTo" on "G".assigned_to = "UTo".id
    INNER JOIN "Users" as "UBy" on "G".assigned_by = "UBy".id
    WHERE "G".is_deactivation != true
`

type GetGlobalModeratorsRow struct {
	ID                 int64     `json:"id"`
	AssignedTo         int64     `json:"assigned_to"`
	AssignedToUsername string    `json:"assigned_to_username"`
	AssignedAt         time.Time `json:"assigned_at"`
	AssignedBy         int64     `json:"assigned_by"`
	AssignedByUsername string    `json:"assigned_by_username"`
}

func (q *Queries) GetGlobalModerators(ctx context.Context) ([]GetGlobalModeratorsRow, error) {
	rows, err := q.db.QueryContext(ctx, getGlobalModerators)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlobalModeratorsRow
	for rows.Next() {
		var i GetGlobalModeratorsRow
		if err := rows.Scan(
			&i.ID,
			&i.AssignedTo,
			&i.AssignedToUsername,
			&i.AssignedAt,
			&i.AssignedBy,
			&i.AssignedByUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getModRecordsForModerator = `-- name: GetModRecordsForModerator :many
SELECT "C"."id", "C".taken_by, "Users".username, "C".comment_id, "C".reason, "C".taken_on, "C".set_hidden_to, "C".set_removed_to, "C".associated_report FROM "CommentModerationActions" as "C" INNER JOIN "Users" ON "C".taken_by = "Users".id WHERE "C".id = $1
`

type GetModRecordsForModeratorRow struct {
	ID               int64          `json:"id"`
	TakenBy          int64          `json:"taken_by"`
	Username         string         `json:"username"`
	CommentID        int64          `json:"comment_id"`
	Reason           sql.NullString `json:"reason"`
	TakenOn          sql.NullTime   `json:"taken_on"`
	SetHiddenTo      sql.NullBool   `json:"set_hidden_to"`
	SetRemovedTo     sql.NullBool   `json:"set_removed_to"`
	AssociatedReport sql.NullInt64  `json:"associated_report"`
}

func (q *Queries) GetModRecordsForModerator(ctx context.Context, id int64) ([]GetModRecordsForModeratorRow, error) {
	rows, err := q.db.QueryContext(ctx, getModRecordsForModerator, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetModRecordsForModeratorRow
	for rows.Next() {
		var i GetModRecordsForModeratorRow
		if err := rows.Scan(
			&i.ID,
			&i.TakenBy,
			&i.Username,
			&i.CommentID,
			&i.Reason,
			&i.TakenOn,
			&i.SetHiddenTo,
			&i.SetRemovedTo,
			&i.AssociatedReport,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFeedbackHidden = `-- name: UpdateFeedbackHidden :exec
UPDATE "Feedbacks" SET hidden = $2
WHERE id = $1
`

type UpdateFeedbackHiddenParams struct {
	ID     int64        `json:"id"`
	Hidden sql.NullBool `json:"hidden"`
}

func (q *Queries) UpdateFeedbackHidden(ctx context.Context, arg UpdateFeedbackHiddenParams) error {
	_, err := q.db.ExecContext(ctx, updateFeedbackHidden, arg.ID, arg.Hidden)
	return err
}
